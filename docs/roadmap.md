# FamilyConnector

## 実装ロードマップ（推奨：7フェーズ）

> フェーズごとに「成果物」「受け入れ条件（Acceptance Criteria）」「技術的な落とし穴」をセットで書きます。
> これに従うと、仕様の思想（後勝ち＋警告、通知はUIで回収、Asset一元）を崩さずに前進できます。

### Phase 0：プロジェクト初期設計（1回で固める）

**成果物**

* リポジトリ構成、モノレポ or 分離（API / Web / iOS）
* APIの契約（OpenAPI）とエンティティ定義（DBスキーマの雛形）
* 監視（最低限：ログ、メトリクス、トレース）方針

**受け入れ条件**

* A〜Gの主要エンティティが「同じ粒度」で表現されている（householdId / memberId / updatedAt / version など）

**落とし穴**

* 画面実装を先にすると、後から同期・冪等で破綻しやすい

---

### Phase 1：共通基盤（E + Gの“背骨”を先に実装）

**優先順位：最優先（ここができると全てが前に進む）**

**成果物**

* 認証（最低限）＋ Household/Member 作成・取得
* **version（楽観ロック）＋後勝ち適用＋警告イベント生成**（サーバ側）
* **clientRequestId による冪等性**（サーバ側）
* 監査ログ/削除ログ（E）書き込み（保持削除バッチは後でもよい）
* Delta Sync API（G）

  * `GET /sync?lastSyncedAt=...` のような形で「updatedAt差分」を返せる

**受け入れ条件**

* 同一 `clientRequestId` を複数回送っても「データ更新・通知・ログ」が**二重発生しない**
* `baseVersion != currentVersion` でも更新が通り、警告イベントが残る
* `updatedAt > lastSyncedAt` の差分取得が全エンティティ共通で動く

**落とし穴**

* 冪等性を「DB更新だけ」に適用して、通知/ログ/派生処理が二重になる（最頻出事故）

---

### Phase 2：Asset基盤（F + G：メディアの一元化と軽量版）

**優先順位：Phase1の次（将来の作り直し回避のROIが高い）**

**成果物**

* Asset 登録（メタ情報＋所有者＋householdId）
* 署名付きURLアップロード（または同等の安全なアップロード経路）
* **軽量版の自動生成ジョブ**（画像）
* 取得API（初期は軽量版URL → 操作で原本/高解像）
* 失敗時のフォールバック（取得失敗表示＋リトライ）

**受け入れ条件**

* レシート画像・メッセージ添付・アバターのいずれも「URL直持ち」ではなく **assetId参照**で成立
* 軽量版がない/生成失敗でもアプリが破綻しない（リトライ導線あり）

**落とし穴**

* とりあえずURL直持ちで進めて後からAsset化（ほぼ確実に移行事故）

---

### Phase 3：D（ホーム）を“薄く”作る（回収地点を先に用意）

**成果物**

* Home API（集約ビュー）

  * C未読サマリ
  * A要対応サマリ
  * B直近時間軸サマリ
  * クイックアクションはUI固定でも可
* Home UI（最小表示）
* “通知見逃し→ホームで回復” の最小ループ

**受け入れ条件**

* 優先順位が仕様通り：**C未読があれば最上段**、なければA、Bは下段
* OS通知なしでも、ホームで「未消化」が見える

**落とし穴**

* 各ドメイン画面が先に増えて、ホームが後付けになり思想が崩れる

---

### Phase 4：価値中核① C（メッセージ）を先に通す

**理由**：家族アプリは、初期は“生活データ”より“コミュニケーション”が利用を牽引しやすい。加えて、Asset・通知・同期の統合テストとして最適。

**成果物**

* Message（free/context）作成・一覧・スレッド表示
* Reaction（ユニーク制約込み）
* Attachment（assetId参照で画像/PDF）
* ReadState（タイムライン単位）
* 通知生成（新規/返信/リアクション）＋ **一意性キー**（G）

**受け入れ条件**

* 返信ツリーがUIで破綻しない（root/parentの一貫性）
* リアクションの二重付与が発生しない（同一member+emoji）
* 通知が「同一ソース×同一受信者で1回」になる

**落とし穴**

* ReadStateを後回しにして、Dの未読回収が機能しない

---

### Phase 5：価値中核② A（出費：レシートOCR）→在庫/買い物は後

**理由**：A-4は「Asset」「ジョブ」「要対応（差分警告）」が全部出るので、基盤の完成度が上がる。

**成果物**

* Receipt/LineItem CRUD（ソフトデリート＋ログ）
* OCRジョブ（失敗→手入力フォールバック）
* **合計不一致の警告**→Dの要対応に表示
* 在庫（A-2）と買い物（A-3）は最小から着手

  * 在庫：qty=0→翌日削除バッチ
  * 買い物：done→1日後削除バッチ

**受け入れ条件**

* LineItemが集計の正、Receipt.totalが総計の正、差分警告が出る
* OCRが失敗してもユーザーが完了できる

**落とし穴**

* OCR精度に時間を溶かす（v1.0は「修正しやすさ」が勝ち）

---

### Phase 6：B（スケジュール・通知）とGoogle連携

**成果物**

* FamilyEvent（RRULE最小対応）＋通知オフセット
* Reminder（完了＝削除扱い＋ログ）
* Google Busy（busyだけ保持・表示・通知）
* 静音時間（E）を最終判定に適用

**受け入れ条件**

* busyは詳細を持たず、共有もbusyのみ
* fireAtが過去なら通知しない（仕様通り）
* 静音で抑制されてもDで回復できる

**落とし穴**

* RRULEの実装難に引っ張られ、MVPが遅れる
  → 最初は「毎日・毎週・隔週・第n曜日」に絞るのは正しい

---

### Phase 7：運用仕上げ（バッチ/監視/障害耐性）

**成果物**

* バッチ（ログ3ヶ月削除、在庫/買い物削除、など仕様の定期処理）
* 監視指標（同期失敗率、通知成功率、OCR成功率、メディア取得失敗率）
* リトライ・エラー文言の整備

**受け入れ条件**

* 主要な失敗ケースで「ユーザーが詰まらない」導線がある
* 事故が起きた時に、原因が追える（ログ＋メトリクス）

---

## MVPの最短「スライス」（動く縦割りを早く作る）

最短で価値を出しつつ、設計の背骨をテストできる順：

1. **E/G基盤**（Household/Member + version + clientRequestId + delta sync）
2. **F Asset**（添付アップロード/軽量版/取得）
3. **C メッセージ（添付あり）** + 通知一意
4. **D ホーム（未読回収）**
5. **A-4 レシート（OCRは最小でも可）** + 要対応
6. **B リマインド**（完了回収の基本）→余力でEvent/Busy

---

## 実装の“定義済みガードレール”（必ず守るルール）

| 領域   | ルール                      | 破ると起きること                |
| ---- | ------------------------ | ----------------------- |
| API  | 変更系は必ず `clientRequestId` | 二重通知・二重ログ・二重作成          |
| 整合性  | `baseVersion` を必須        | 後勝ち警告の一貫性が崩れる           |
| 同期   | 全エンティティに `updatedAt`     | Delta Syncがドメインごとに別物になる |
| メディア | URL直持ち禁止（assetId参照）      | 失効/再署名・軽量版導入で破綻         |
| UX   | Dは常に回収地点                 | 通知見逃しが致命傷になる            |

---

## 次にやると良い具体タスク（チェックリスト）

1. **技術スタック決定**（iOS/Android/Web、バックエンド、ストレージ、キュー）
2. **OpenAPIを先に書く**（A〜Gの必須エンドポイントを固定）
3. **DBスキーマ草案**（共通カラム：householdId/updatedAt/version/deletedAt）
4. **冪等性の実装方式**（idempotency table など）
5. **Home集約APIの形**（ドメイン別に引くのか、サーバで集約するのか）
6. **ジョブ基盤**（OCR、通知、軽量版生成、期限削除バッチ）
